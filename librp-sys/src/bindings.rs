/* automatically generated by rust-bindgen 0.63.0 */

pub const RP_MODEL: &[u8; 4usize] = b"Z10\0";
pub const ADC_SAMPLE_RATE: f64 = 125000000.0;
pub const ADC_BITS: u32 = 14;
pub const ADC_REG_BITS: u32 = 14;
pub const ADC_BITS_MASK: u32 = 16383;
pub const ADC_REG_BITS_MASK: u32 = 16383;
pub const DAC_FREQUENCY: f64 = 125000000.0;
pub const ADC_BUFFER_SIZE: u32 = 16384;
pub const BUFFER_LENGTH: u32 = 16384;
pub const RP_OK: u32 = 0;
pub const RP_EOED: u32 = 1;
pub const RP_EOMD: u32 = 2;
pub const RP_ECMD: u32 = 3;
pub const RP_EMMD: u32 = 4;
pub const RP_EUMD: u32 = 5;
pub const RP_EOOR: u32 = 6;
pub const RP_ELID: u32 = 7;
pub const RP_EMRO: u32 = 8;
pub const RP_EWIP: u32 = 9;
pub const RP_EPN: u32 = 10;
pub const RP_UIA: u32 = 11;
pub const RP_FCA: u32 = 12;
pub const RP_RCA: u32 = 13;
pub const RP_BTS: u32 = 14;
pub const RP_EIPV: u32 = 15;
pub const RP_EUF: u32 = 16;
pub const RP_ENN: u32 = 17;
pub const RP_EFOB: u32 = 18;
pub const RP_EFCB: u32 = 19;
pub const RP_EABA: u32 = 20;
pub const RP_EFRB: u32 = 21;
pub const RP_EFWB: u32 = 22;
pub const RP_EMNC: u32 = 23;
pub const RP_NOTS: u32 = 24;
pub const SPECTR_OUT_SIG_LEN: u32 = 2048;
#[doc = "!< LED 0"]
pub const rp_dpin_t_RP_LED0: rp_dpin_t = 0;
#[doc = "!< LED 1"]
pub const rp_dpin_t_RP_LED1: rp_dpin_t = 1;
#[doc = "!< LED 2"]
pub const rp_dpin_t_RP_LED2: rp_dpin_t = 2;
#[doc = "!< LED 3"]
pub const rp_dpin_t_RP_LED3: rp_dpin_t = 3;
#[doc = "!< LED 4"]
pub const rp_dpin_t_RP_LED4: rp_dpin_t = 4;
#[doc = "!< LED 5"]
pub const rp_dpin_t_RP_LED5: rp_dpin_t = 5;
#[doc = "!< LED 6"]
pub const rp_dpin_t_RP_LED6: rp_dpin_t = 6;
#[doc = "!< LED 7"]
pub const rp_dpin_t_RP_LED7: rp_dpin_t = 7;
#[doc = "!< DIO_P 0"]
pub const rp_dpin_t_RP_DIO0_P: rp_dpin_t = 8;
#[doc = "!< DIO_P 1"]
pub const rp_dpin_t_RP_DIO1_P: rp_dpin_t = 9;
#[doc = "!< DIO_P 2"]
pub const rp_dpin_t_RP_DIO2_P: rp_dpin_t = 10;
#[doc = "!< DIO_P 3"]
pub const rp_dpin_t_RP_DIO3_P: rp_dpin_t = 11;
#[doc = "!< DIO_P 4"]
pub const rp_dpin_t_RP_DIO4_P: rp_dpin_t = 12;
#[doc = "!< DIO_P 5"]
pub const rp_dpin_t_RP_DIO5_P: rp_dpin_t = 13;
#[doc = "!< DIO_P 6"]
pub const rp_dpin_t_RP_DIO6_P: rp_dpin_t = 14;
#[doc = "!< DIO_P 7"]
pub const rp_dpin_t_RP_DIO7_P: rp_dpin_t = 15;
#[doc = "!< DIO_N 0"]
pub const rp_dpin_t_RP_DIO0_N: rp_dpin_t = 16;
#[doc = "!< DIO_N 1"]
pub const rp_dpin_t_RP_DIO1_N: rp_dpin_t = 17;
#[doc = "!< DIO_N 2"]
pub const rp_dpin_t_RP_DIO2_N: rp_dpin_t = 18;
#[doc = "!< DIO_N 3"]
pub const rp_dpin_t_RP_DIO3_N: rp_dpin_t = 19;
#[doc = "!< DIO_N 4"]
pub const rp_dpin_t_RP_DIO4_N: rp_dpin_t = 20;
#[doc = "!< DIO_N 5"]
pub const rp_dpin_t_RP_DIO5_N: rp_dpin_t = 21;
#[doc = "!< DIO_N 6"]
pub const rp_dpin_t_RP_DIO6_N: rp_dpin_t = 22;
#[doc = "!< DIO_N 7"]
pub const rp_dpin_t_RP_DIO7_N: rp_dpin_t = 23;
#[doc = " Type representing digital input output pins."]
pub type rp_dpin_t = ::std::os::raw::c_uint;
#[doc = "!< Low state"]
pub const rp_pinState_t_RP_LOW: rp_pinState_t = 0;
#[doc = "!< High state"]
pub const rp_pinState_t_RP_HIGH: rp_pinState_t = 1;
#[doc = " Type representing pin's high or low state (on/off)."]
pub type rp_pinState_t = ::std::os::raw::c_uint;
#[doc = "!< Input direction"]
pub const rp_pinDirection_t_RP_IN: rp_pinDirection_t = 0;
#[doc = "!< Output direction"]
pub const rp_pinDirection_t_RP_OUT: rp_pinDirection_t = 1;
#[doc = " Type representing pin's input or output direction."]
pub type rp_pinDirection_t = ::std::os::raw::c_uint;
#[doc = "!< Analog output 0"]
pub const rp_apin_t_RP_AOUT0: rp_apin_t = 0;
#[doc = "!< Analog output 1"]
pub const rp_apin_t_RP_AOUT1: rp_apin_t = 1;
#[doc = "!< Analog output 2"]
pub const rp_apin_t_RP_AOUT2: rp_apin_t = 2;
#[doc = "!< Analog output 3"]
pub const rp_apin_t_RP_AOUT3: rp_apin_t = 3;
#[doc = "!< Analog input 0"]
pub const rp_apin_t_RP_AIN0: rp_apin_t = 4;
#[doc = "!< Analog input 1"]
pub const rp_apin_t_RP_AIN1: rp_apin_t = 5;
#[doc = "!< Analog input 2"]
pub const rp_apin_t_RP_AIN2: rp_apin_t = 6;
#[doc = "!< Analog input 3"]
pub const rp_apin_t_RP_AIN3: rp_apin_t = 7;
#[doc = " Type representing analog input output pins."]
pub type rp_apin_t = ::std::os::raw::c_uint;
#[doc = "!< Wave form sine"]
pub const rp_waveform_t_RP_WAVEFORM_SINE: rp_waveform_t = 0;
#[doc = "!< Wave form square"]
pub const rp_waveform_t_RP_WAVEFORM_SQUARE: rp_waveform_t = 1;
#[doc = "!< Wave form triangle"]
pub const rp_waveform_t_RP_WAVEFORM_TRIANGLE: rp_waveform_t = 2;
#[doc = "!< Wave form sawtooth (/|)"]
pub const rp_waveform_t_RP_WAVEFORM_RAMP_UP: rp_waveform_t = 3;
#[doc = "!< Wave form reversed sawtooth (|\\)"]
pub const rp_waveform_t_RP_WAVEFORM_RAMP_DOWN: rp_waveform_t = 4;
#[doc = "!< Wave form dc"]
pub const rp_waveform_t_RP_WAVEFORM_DC: rp_waveform_t = 5;
#[doc = "!< Wave form pwm"]
pub const rp_waveform_t_RP_WAVEFORM_PWM: rp_waveform_t = 6;
#[doc = "!< Use defined wave form"]
pub const rp_waveform_t_RP_WAVEFORM_ARBITRARY: rp_waveform_t = 7;
#[doc = "!< Wave form negative dc"]
pub const rp_waveform_t_RP_WAVEFORM_DC_NEG: rp_waveform_t = 8;
#[doc = "!< Wave form sweep"]
pub const rp_waveform_t_RP_WAVEFORM_SWEEP: rp_waveform_t = 9;
pub type rp_waveform_t = ::std::os::raw::c_uint;
#[doc = "!< Continuous signal generation"]
pub const rp_gen_mode_t_RP_GEN_MODE_CONTINUOUS: rp_gen_mode_t = 0;
#[doc = "!< Signal is generated N times, wher N is defined with\n!< rp_GenBurstCount method"]
pub const rp_gen_mode_t_RP_GEN_MODE_BURST: rp_gen_mode_t = 1;
#[doc = "!< User can continuously write data to buffer"]
pub const rp_gen_mode_t_RP_GEN_MODE_STREAM: rp_gen_mode_t = 2;
pub type rp_gen_mode_t = ::std::os::raw::c_uint;
#[doc = "!< Generate sweep signal from start frequency to\n!< end frequency"]
pub const rp_gen_sweep_dir_t_RP_GEN_SWEEP_DIR_NORMAL: rp_gen_sweep_dir_t = 0;
#[doc = "!< Generate sweep signal from start frequency to\n!< end frequency and back to start frequency"]
pub const rp_gen_sweep_dir_t_RP_GEN_SWEEP_DIR_UP_DOWN: rp_gen_sweep_dir_t = 1;
pub type rp_gen_sweep_dir_t = ::std::os::raw::c_uint;
#[doc = "!< Generate sweep signal in linear mode"]
pub const rp_gen_sweep_mode_t_RP_GEN_SWEEP_MODE_LINEAR: rp_gen_sweep_mode_t = 0;
#[doc = "!< Generate sweep signal in log mode"]
pub const rp_gen_sweep_mode_t_RP_GEN_SWEEP_MODE_LOG: rp_gen_sweep_mode_t = 1;
pub type rp_gen_sweep_mode_t = ::std::os::raw::c_uint;
#[doc = "!< Internal trigger source"]
pub const rp_trig_src_t_RP_GEN_TRIG_SRC_INTERNAL: rp_trig_src_t = 1;
#[doc = "!< External trigger source positive edge"]
pub const rp_trig_src_t_RP_GEN_TRIG_SRC_EXT_PE: rp_trig_src_t = 2;
#[doc = "!< External trigger source negative edge"]
pub const rp_trig_src_t_RP_GEN_TRIG_SRC_EXT_NE: rp_trig_src_t = 3;
pub type rp_trig_src_t = ::std::os::raw::c_uint;
#[doc = "!< Channel A"]
pub const rp_channel_t_RP_CH_1: rp_channel_t = 0;
#[doc = "!< Channel B"]
pub const rp_channel_t_RP_CH_2: rp_channel_t = 1;
#[doc = " Type representing Input/Output channels."]
pub type rp_channel_t = ::std::os::raw::c_uint;
#[doc = "!< Channel A"]
pub const rp_channel_trigger_t_RP_T_CH_1: rp_channel_trigger_t = 0;
#[doc = "!< Channel B"]
pub const rp_channel_trigger_t_RP_T_CH_2: rp_channel_trigger_t = 1;
pub const rp_channel_trigger_t_RP_T_CH_EXT: rp_channel_trigger_t = 2;
#[doc = " Type representing Input/Output channels in trigger."]
pub type rp_channel_trigger_t = ::std::os::raw::c_uint;
#[doc = "!< AA"]
pub const rp_eq_filter_cof_t_AA: rp_eq_filter_cof_t = 0;
#[doc = "!< BB"]
pub const rp_eq_filter_cof_t_BB: rp_eq_filter_cof_t = 1;
#[doc = "!< PP"]
pub const rp_eq_filter_cof_t_PP: rp_eq_filter_cof_t = 2;
#[doc = "!< KK"]
pub const rp_eq_filter_cof_t_KK: rp_eq_filter_cof_t = 3;
#[doc = " The type represents the names of the coefficients in the filter."]
pub type rp_eq_filter_cof_t = ::std::os::raw::c_uint;
pub const rp_acq_sampling_rate_t_RP_SMP_125M: rp_acq_sampling_rate_t = 1;
pub const rp_acq_sampling_rate_t_RP_SMP_62_500M: rp_acq_sampling_rate_t = 2;
pub const rp_acq_sampling_rate_t_RP_SMP_31_250M: rp_acq_sampling_rate_t = 4;
pub const rp_acq_sampling_rate_t_RP_SMP_15_625M: rp_acq_sampling_rate_t = 8;
pub const rp_acq_sampling_rate_t_RP_SMP_7_812M: rp_acq_sampling_rate_t = 16;
pub const rp_acq_sampling_rate_t_RP_SMP_3_906M: rp_acq_sampling_rate_t = 32;
pub const rp_acq_sampling_rate_t_RP_SMP_1_953M: rp_acq_sampling_rate_t = 64;
pub const rp_acq_sampling_rate_t_RP_SMP_976_562K: rp_acq_sampling_rate_t = 128;
pub const rp_acq_sampling_rate_t_RP_SMP_448_281K: rp_acq_sampling_rate_t = 256;
pub const rp_acq_sampling_rate_t_RP_SMP_244_140K: rp_acq_sampling_rate_t = 512;
#[doc = "!< Sample rate 122.070ksps; Buffer time length\n!< 134.2ms; Decimation 1024"]
pub const rp_acq_sampling_rate_t_RP_SMP_122_070K: rp_acq_sampling_rate_t = 1024;
#[doc = "!< Sample rate 61.035ksps; Buffer time length\n!< 268.288ms; Decimation 2048"]
pub const rp_acq_sampling_rate_t_RP_SMP_61_035K: rp_acq_sampling_rate_t = 2048;
#[doc = "!< Sample rate 30.517ksps; Buffer time length\n!< 536.5ms; Decimation 4096"]
pub const rp_acq_sampling_rate_t_RP_SMP_30_517K: rp_acq_sampling_rate_t = 4096;
#[doc = "!< Sample rate 15.258ksps; Buffer time length 1.073s;\n!< Decimation 8192"]
pub const rp_acq_sampling_rate_t_RP_SMP_15_258K: rp_acq_sampling_rate_t = 8192;
#[doc = "!< Sample rate 7.629ksps; Buffer time length 2.146s;\n!< Decimation 16384"]
pub const rp_acq_sampling_rate_t_RP_SMP_7_629K: rp_acq_sampling_rate_t = 16384;
#[doc = "!< Sample rate 3.814ksps; Buffer time length 4.292s;\n!< Decimation 32768"]
pub const rp_acq_sampling_rate_t_RP_SMP_3_814K: rp_acq_sampling_rate_t = 32768;
#[doc = "!< Sample rate 1.907ksps; Buffer time length 8.589s;\n!< Decimation 65536"]
pub const rp_acq_sampling_rate_t_RP_SMP_1_907K: rp_acq_sampling_rate_t = 65536;
#[doc = " Type representing acquire signal sampling rate."]
pub type rp_acq_sampling_rate_t = ::std::os::raw::c_uint;
#[doc = "!< Sample rate 125Msps; Buffer time length 131us; Decimation 1"]
pub const rp_acq_decimation_t_RP_DEC_1: rp_acq_decimation_t = 1;
pub const rp_acq_decimation_t_RP_DEC_2: rp_acq_decimation_t = 2;
pub const rp_acq_decimation_t_RP_DEC_4: rp_acq_decimation_t = 4;
pub const rp_acq_decimation_t_RP_DEC_8: rp_acq_decimation_t = 8;
pub const rp_acq_decimation_t_RP_DEC_16: rp_acq_decimation_t = 16;
pub const rp_acq_decimation_t_RP_DEC_32: rp_acq_decimation_t = 32;
pub const rp_acq_decimation_t_RP_DEC_64: rp_acq_decimation_t = 64;
pub const rp_acq_decimation_t_RP_DEC_128: rp_acq_decimation_t = 128;
pub const rp_acq_decimation_t_RP_DEC_256: rp_acq_decimation_t = 256;
pub const rp_acq_decimation_t_RP_DEC_512: rp_acq_decimation_t = 512;
#[doc = "!< Sample rate 122.070ksps; Buffer time length 134.2ms;\n!< Decimation 1024"]
pub const rp_acq_decimation_t_RP_DEC_1024: rp_acq_decimation_t = 1024;
#[doc = "!< Sample rate 61.035ksps; Buffer time length 268.288ms;\n!< Decimation 2048"]
pub const rp_acq_decimation_t_RP_DEC_2048: rp_acq_decimation_t = 2048;
#[doc = "!< Sample rate 30.517ksps; Buffer time length 536.5ms;\n!< Decimation 4096"]
pub const rp_acq_decimation_t_RP_DEC_4096: rp_acq_decimation_t = 4096;
#[doc = "!< Sample rate 15.258ksps; Buffer time length 1.073s;\n!< Decimation 8192"]
pub const rp_acq_decimation_t_RP_DEC_8192: rp_acq_decimation_t = 8192;
#[doc = "!< Sample rate 7.629ksps; Buffer time length 2.146s;\n!< Decimation 16384"]
pub const rp_acq_decimation_t_RP_DEC_16384: rp_acq_decimation_t = 16384;
#[doc = "!< Sample rate 3.814ksps; Buffer time length 4.292s;\n!< Decimation 32768"]
pub const rp_acq_decimation_t_RP_DEC_32768: rp_acq_decimation_t = 32768;
#[doc = "!< Sample rate 1.907ksps; Buffer time length 8.589s;\n!< Decimation 65536"]
pub const rp_acq_decimation_t_RP_DEC_65536: rp_acq_decimation_t = 65536;
#[doc = " Type representing decimation used at acquiring signal."]
pub type rp_acq_decimation_t = ::std::os::raw::c_uint;
#[doc = "!< Trigger is disabled"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_DISABLED: rp_acq_trig_src_t = 0;
#[doc = "!< Trigger triggered now (immediately)"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_NOW: rp_acq_trig_src_t = 1;
#[doc = "!< Trigger set to Channel A threshold positive edge"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_CHA_PE: rp_acq_trig_src_t = 2;
#[doc = "!< Trigger set to Channel A threshold negative edge"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_CHA_NE: rp_acq_trig_src_t = 3;
#[doc = "!< Trigger set to Channel B threshold positive edge"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_CHB_PE: rp_acq_trig_src_t = 4;
#[doc = "!< Trigger set to Channel B threshold negative edge"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_CHB_NE: rp_acq_trig_src_t = 5;
#[doc = "!< Trigger set to external trigger positive edge (DIO0_P\n!< pin)"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_EXT_PE: rp_acq_trig_src_t = 6;
#[doc = "!< Trigger set to external trigger negative edge (DIO0_P\n!< pin)"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_EXT_NE: rp_acq_trig_src_t = 7;
#[doc = "!< Trigger set to arbitrary wave generator application\n!< positive edge"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_AWG_PE: rp_acq_trig_src_t = 8;
#[doc = "!< Trigger set to arbitrary wave generator application\n!< negative edge"]
pub const rp_acq_trig_src_t_RP_TRIG_SRC_AWG_NE: rp_acq_trig_src_t = 9;
#[doc = " Type representing different trigger sources used at acquiring signal."]
pub type rp_acq_trig_src_t = ::std::os::raw::c_uint;
#[doc = "!< Trigger is triggered/disabled"]
pub const rp_acq_trig_state_t_RP_TRIG_STATE_TRIGGERED: rp_acq_trig_state_t = 0;
#[doc = "!< Trigger is set up and waiting (to be triggered)"]
pub const rp_acq_trig_state_t_RP_TRIG_STATE_WAITING: rp_acq_trig_state_t = 1;
#[doc = " Type representing different trigger states."]
pub type rp_acq_trig_state_t = ::std::os::raw::c_uint;
#[doc = " Calibration parameters, stored in the EEPROM device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rp_calib_params_t {
    #[doc = "!< High gain front end full scale voltage, channel A"]
    pub fe_ch1_fs_g_hi: u32,
    #[doc = "!< High gain front end full scale voltage, channel B"]
    pub fe_ch2_fs_g_hi: u32,
    #[doc = "!< Low gain front end full scale voltage, channel A"]
    pub fe_ch1_fs_g_lo: u32,
    #[doc = "!< Low gain front end full scale voltage, channel B"]
    pub fe_ch2_fs_g_lo: u32,
    #[doc = "!< Front end DC offset, channel A"]
    pub fe_ch1_lo_offs: i32,
    #[doc = "!< Front end DC offset, channel B"]
    pub fe_ch2_lo_offs: i32,
    #[doc = "!< Back end full scale voltage, channel A"]
    pub be_ch1_fs: u32,
    #[doc = "!< Back end full scale voltage, channel B"]
    pub be_ch2_fs: u32,
    #[doc = "!< Back end DC offset, channel A"]
    pub be_ch1_dc_offs: i32,
    #[doc = "!< Back end DC offset, on channel B"]
    pub be_ch2_dc_offs: i32,
    pub magic: u32,
    #[doc = "!< Front end DC offset, channel A"]
    pub fe_ch1_hi_offs: i32,
    #[doc = "!< Front end DC offset, channel B"]
    pub fe_ch2_hi_offs: i32,
    #[doc = "!< Filter equalization coefficients AA for Low\n!< mode, channel A"]
    pub low_filter_aa_ch1: u32,
    #[doc = "!< Filter equalization coefficients BB for Low\n!< mode, channel A"]
    pub low_filter_bb_ch1: u32,
    #[doc = "!< Filter equalization coefficients PP for Low\n!< mode, channel A"]
    pub low_filter_pp_ch1: u32,
    #[doc = "!< Filter equalization coefficients KK for Low\n!< mode, channel A"]
    pub low_filter_kk_ch1: u32,
    #[doc = "!< Filter equalization coefficients AA for Low\n!< mode, channel B"]
    pub low_filter_aa_ch2: u32,
    #[doc = "!< Filter equalization coefficients BB for Low\n!< mode, channel B"]
    pub low_filter_bb_ch2: u32,
    #[doc = "!< Filter equalization coefficients PP for Low\n!< mode, channel B"]
    pub low_filter_pp_ch2: u32,
    #[doc = "!< Filter equalization coefficients KK for Low\n!< mode, channel B"]
    pub low_filter_kk_ch2: u32,
    #[doc = "!< Filter equalization coefficients AA for High\n!< mode, channel A"]
    pub hi_filter_aa_ch1: u32,
    #[doc = "!< Filter equalization coefficients BB for High\n!< mode, channel A"]
    pub hi_filter_bb_ch1: u32,
    #[doc = "!< Filter equalization coefficients PP for High\n!< mode, channel A"]
    pub hi_filter_pp_ch1: u32,
    #[doc = "!< Filter equalization coefficients KK for High\n!< mode, channel A"]
    pub hi_filter_kk_ch1: u32,
    #[doc = "!< Filter equalization coefficients AA for High\n!< mode, channel B"]
    pub hi_filter_aa_ch2: u32,
    #[doc = "!< Filter equalization coefficients BB for High\n!< mode, channel B"]
    pub hi_filter_bb_ch2: u32,
    #[doc = "!< Filter equalization coefficients PP for High\n!< mode, channel B"]
    pub hi_filter_pp_ch2: u32,
    #[doc = "!< Filter equalization coefficients KK for High\n!< mode, channel B"]
    pub hi_filter_kk_ch2: u32,
}
#[test]
fn bindgen_test_layout_rp_calib_params_t() {
    const UNINIT: ::std::mem::MaybeUninit<rp_calib_params_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rp_calib_params_t>(),
        116usize,
        concat!("Size of: ", stringify!(rp_calib_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rp_calib_params_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rp_calib_params_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fe_ch1_fs_g_hi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(fe_ch1_fs_g_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fe_ch2_fs_g_hi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(fe_ch2_fs_g_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fe_ch1_fs_g_lo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(fe_ch1_fs_g_lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fe_ch2_fs_g_lo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(fe_ch2_fs_g_lo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fe_ch1_lo_offs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(fe_ch1_lo_offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fe_ch2_lo_offs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(fe_ch2_lo_offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).be_ch1_fs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(be_ch1_fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).be_ch2_fs) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(be_ch2_fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).be_ch1_dc_offs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(be_ch1_dc_offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).be_ch2_dc_offs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(be_ch2_dc_offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fe_ch1_hi_offs) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(fe_ch1_hi_offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fe_ch2_hi_offs) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(fe_ch2_hi_offs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_filter_aa_ch1) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(low_filter_aa_ch1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_filter_bb_ch1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(low_filter_bb_ch1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_filter_pp_ch1) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(low_filter_pp_ch1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_filter_kk_ch1) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(low_filter_kk_ch1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_filter_aa_ch2) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(low_filter_aa_ch2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_filter_bb_ch2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(low_filter_bb_ch2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_filter_pp_ch2) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(low_filter_pp_ch2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_filter_kk_ch2) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(low_filter_kk_ch2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi_filter_aa_ch1) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(hi_filter_aa_ch1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi_filter_bb_ch1) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(hi_filter_bb_ch1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi_filter_pp_ch1) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(hi_filter_pp_ch1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi_filter_kk_ch1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(hi_filter_kk_ch1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi_filter_aa_ch2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(hi_filter_aa_ch2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi_filter_bb_ch2) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(hi_filter_bb_ch2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi_filter_pp_ch2) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(hi_filter_pp_ch2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi_filter_kk_ch2) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rp_calib_params_t),
            "::",
            stringify!(hi_filter_kk_ch2)
        )
    );
}
extern "C" {
    #[doc = " Initializes the library. It must be called first, before any other library\n method.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_Init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes the library. It must be called first, before any other library\n method.\n @param reset Reset to default configuration on api\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_InitReset(reset: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_IsApiInit() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_CalibInit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Releases the library resources. It must be called last, after library is not\n used anymore. Typically before application exits.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_Release() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resets all modules. Typically calles after rp_Init()\n application exits.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_Reset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves the library version number\n @return Library version"]
    pub fn rp_GetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns textual representation of error code.\n @param errorCode Error code returned from API.\n @return Textual representation of error given error code."]
    pub fn rp_GetError(errorCode: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enable or disables digital loop. This internally connect output to input\n @param enable True if you want to enable this feature or false if you want to\n disable it Each rp_GetCalibrationSettings call returns the same cached\n setting values.\n @return Calibration settings"]
    pub fn rp_EnableDigitalLoop(enable: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns calibration settings.\n These calibration settings are populated only once from EEPROM at rp_Init().\n Each rp_GetCalibrationSettings call returns the same cached setting values.\n @return Calibration settings"]
    pub fn rp_GetCalibrationSettings() -> rp_calib_params_t;
}
extern "C" {
    #[doc = " Returns default calibration settings.\n These calibration settings are populated only once from EEPROM at rp_Init().\n Each rp_GetCalibrationSettings call returns the same cached setting values.\n @return Calibration settings"]
    pub fn rp_GetDefaultCalibrationSettings() -> rp_calib_params_t;
}
extern "C" {
    #[doc = " Calibrates input channel offset. This input channel must be grounded to\n calibrate properly. Calibration data is written to EPROM and repopulated so\n that rp_GetCalibrationSettings works properly.\n @param channel Channel witch is going to be calibrated\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrateFrontEndOffset(
        channel: rp_channel_t,
        gain: rp_pinState_t,
        out_params: *mut rp_calib_params_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calibrates input channel low voltage scale. Jumpers must be set to LV.\n This input channel must be connected to stable positive source.\n Calibration data is written to EPROM and repopulated so that\n rp_GetCalibrationSettings works properly.\n @param channel Channel witch is going to be calibrated\n @param referentialVoltage Voltage of the source.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrateFrontEndScaleLV(
        channel: rp_channel_t,
        referentialVoltage: f32,
        out_params: *mut rp_calib_params_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calibrates input channel high voltage scale. Jumpers must be set to HV.\n This input channel must be connected to stable positive source.\n Calibration data is written to EPROM and repopulated so that\n rp_GetCalibrationSettings works properly.\n @param channel Channel witch is going to be calibrated\n @param referentialVoltage Voltage of the source.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrateFrontEndScaleHV(
        channel: rp_channel_t,
        referentialVoltage: f32,
        out_params: *mut rp_calib_params_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calibrates output channel offset.\n This input channel must be connected to calibrated input channel with came\n number (CH1 to CH1 and CH2 to CH2). Calibration data is written to EPROM and\n repopulated so that rp_GetCalibrationSettings works properly.\n @param channel Channel witch is going to be calibrated\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrateBackEndOffset(channel: rp_channel_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calibrates output channel voltage scale.\n This input channel must be connected to calibrated input channel with came\n number (CH1 to CH1 and CH2 to CH2). Calibration data is written to EPROM and\n repopulated so that rp_GetCalibrationSettings works properly.\n @param channel Channel witch is going to be calibrated\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrateBackEndScale(channel: rp_channel_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calibrates output channel.\n This input channel must be connected to calibrated input channel with came\n number (CH1 to CH1 and CH2 to CH2). Calibration data is written to EPROM and\n repopulated so that rp_GetCalibrationSettings works properly.\n @param channel Channel witch is going to be calibrated\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrateBackEnd(
        channel: rp_channel_t,
        out_params: *mut rp_calib_params_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set default calibration values.\n Calibration data is written to EPROM and repopulated so that\n rp_GetCalibrationSettings works properly.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrationReset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy factory calibration values into user eeprom.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrationFactoryReset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set saved calibration values in case of roll-back calibration.\n Calibration data is written to EPROM and repopulated so that\n rp_GetCalibrationSettings works properly.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrationSetCachedParams() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write calibration values.\n Calibration data is written to EPROM and repopulated so that\n rp_GetCalibrationSettings works properly.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrationWriteParams(calib_params: rp_calib_params_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set calibration values in memory.\n Calibration values are written to temporary memory, but not permanently.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_CalibrationSetParams(calib_params: rp_calib_params_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets FPGA Synthesized ID"]
    pub fn rp_IdGetID(id: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets FPGA Unique DNA"]
    pub fn rp_IdGetDNA(dna: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LED methods"]
    pub fn rp_LEDSetState(state: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_LEDGetState(state: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " GPIO methods"]
    pub fn rp_GPIOnSetDirection(direction: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_GPIOnGetDirection(direction: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_GPIOnSetState(state: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_GPIOnGetState(state: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_GPIOpSetDirection(direction: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_GPIOpGetDirection(direction: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_GPIOpSetState(state: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_GPIOpGetState(state: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets digital pins to default values. Pins DIO1_P - DIO7_P, RP_DIO0_N -\n RP_DIO7_N are set al OUTPUT and to LOW. LEDs are set to LOW/OFF"]
    pub fn rp_DpinReset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets digital input output pin state.\n @param pin    Digital input output pin.\n @param state  High/Low state that will be set at the given pin.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_DpinSetState(pin: rp_dpin_t, state: rp_pinState_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets digital input output pin state.\n @param pin    Digital input output pin.\n @param state  High/Low state that is set at the given pin.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_DpinGetState(pin: rp_dpin_t, state: *mut rp_pinState_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets digital input output pin direction. LED pins are already automatically\n set to the output direction, and they cannot be set to the input direction.\n DIOx_P and DIOx_N are must set either output or input direction before they\n can be used. When set to input direction, it is not allowed to write into\n these pins.\n @param pin        Digital input output pin.\n @param direction  In/Out direction that will be set at the given pin.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_DpinSetDirection(
        pin: rp_dpin_t,
        direction: rp_pinDirection_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets digital input output pin direction.\n @param pin        Digital input output pin.\n @param direction  In/Out direction that is set at the given pin.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_DpinGetDirection(
        pin: rp_dpin_t,
        direction: *mut rp_pinDirection_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets analog outputs to default values (0V)."]
    pub fn rp_ApinReset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets value from analog pin in volts.\n @param pin    Analog pin.\n @param value  Value on analog pin in volts\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_ApinGetValue(pin: rp_apin_t, value: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets raw value from analog pin.\n @param pin    Analog pin.\n @param value  Raw value on analog pin\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_ApinGetValueRaw(pin: rp_apin_t, value: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets value in volts on analog output pin.\n @param pin    Analog output pin.\n @param value  Value in volts to be set on given output pin.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_ApinSetValue(pin: rp_apin_t, value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets raw value on analog output pin.\n @param pin    Analog output pin.\n @param value  Raw value to be set on given output pin.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_ApinSetValueRaw(pin: rp_apin_t, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets range in volts on specific pin.\n @param pin      Analog input output pin.\n @param min_val  Minimum value in volts on given pin.\n @param max_val  Maximum value in volts on given pin.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_ApinGetRange(
        pin: rp_apin_t,
        min_val: *mut f32,
        max_val: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets value from analog pin in volts.\n @param pin    pin index\n @param value  voltage\n @return       RP_OK - successful, RP_E* - failure"]
    pub fn rp_AIpinGetValue(pin: ::std::os::raw::c_uint, value: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets raw value from analog pin.\n @param pin    pin index\n @param value  raw 12 bit XADC value\n @return       RP_OK - successful, RP_E* - failure"]
    pub fn rp_AIpinGetValueRaw(
        pin: ::std::os::raw::c_uint,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets analog outputs to default values (0V)."]
    pub fn rp_AOpinReset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets value from analog pin in volts.\n @param pin    Analog output pin index.\n @param value  Value on analog pin in volts\n @return       RP_OK - successful, RP_E* - failure"]
    pub fn rp_AOpinGetValue(pin: ::std::os::raw::c_uint, value: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets raw value from analog pin.\n @param pin    Analog output pin index.\n @param value  Raw value on analog pin\n @return       RP_OK - successful, RP_E* - failure"]
    pub fn rp_AOpinGetValueRaw(
        pin: ::std::os::raw::c_uint,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets value in volts on analog output pin.\n @param pin    Analog output pin index.\n @param value  Value in volts to be set on given output pin.\n @return       RP_OK - successful, RP_E* - failure"]
    pub fn rp_AOpinSetValue(pin: ::std::os::raw::c_uint, value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets raw value on analog output pin.\n @param pin    Analog output pin index.\n @param value  Raw value to be set on given output pin.\n @return       RP_OK - successful, RP_E* - failure"]
    pub fn rp_AOpinSetValueRaw(pin: ::std::os::raw::c_uint, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets range in volts on specific pin.\n @param pin      Analog input output pin index.\n @param min_val  Minimum value in volts on given pin.\n @param max_val  Maximum value in volts on given pin.\n @return       RP_OK - successful, RP_E* - failure"]
    pub fn rp_AOpinGetRange(
        pin: ::std::os::raw::c_uint,
        min_val: *mut f32,
        max_val: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables continous acquirement even after trigger has happened.\n @param enable True for enabling and false disabling\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetArmKeep(enable: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets status of continous acquirement even after trigger has happened.\n @param state Returns status\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetArmKeep(state: *mut bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Indicates whether the ADC buffer was full of data. The length of the buffer\n is determined by the delay. By default, the delay is half the buffer.\n @param state Returns status\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetBufferFillState(state: *mut bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the decimation used at acquiring signal. There is only a set of\n pre-defined decimation values which can be specified. See the\n #rp_acq_decimation_t enum values.\n @param decimation Specify one of pre-defined decimation values\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetDecimation(decimation: rp_acq_decimation_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the decimation used at acquiring signal. There is only a set of\n pre-defined decimation values which can be specified. See the\n #rp_acq_decimation_t enum values.\n @param decimation Returns one of pre-defined decimation values which is\n currently set.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDecimation(decimation: *mut rp_acq_decimation_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert factor to decimation used at acquiring signal. There is only a get of\n pre-defined decimation values which can be specified. See the\n #rp_acq_decimation_t enum values.\n @param factor Decimation factor.\n @param decimation Returns one of pre-defined decimation values which is\n currently set.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqConvertFactorToDecimation(
        factor: u32,
        decimation: *mut rp_acq_decimation_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the decimation used at acquiring signal.\n You can specify values in the range (1,2,4,8,16-65536)\n @param decimation Decimation values\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetDecimationFactor(decimation: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the decimation factor used at acquiring signal in a numerical form.\n Although this method returns an integer value representing the current factor\n of the decimation, there is only a set of pre-defined decimation factor\n values which can be returned. See the #rp_acq_decimation_t enum values.\n @param decimation Returns decimation factor value which is currently set.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDecimationFactor(decimation: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the sampling rate for acquiring signal. There is only a set of\n pre-defined sampling rate values which can be specified. See the\n #rp_acq_sampling_rate_t enum values.\n @param sampling_rate Specify one of pre-defined sampling rate value\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetSamplingRate(sampling_rate: rp_acq_sampling_rate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the sampling rate for acquiring signal. There is only a set of\n pre-defined sampling rate values which can be returned. See the\n #rp_acq_sampling_rate_t enum values.\n @param sampling_rate Returns one of pre-defined sampling rate value which is\n currently set\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetSamplingRate(
        sampling_rate: *mut rp_acq_sampling_rate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the sampling rate for acquiring signal in a numerical form in Hz.\n Although this method returns a float value representing the current value of\n the sampling rate, there is only a set of pre-defined sampling rate values\n which can be returned. See the #rp_acq_sampling_rate_t enum values.\n @param sampling_rate returns currently set sampling rate in Hz\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetSamplingRateHz(sampling_rate: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables or disables averaging of data between samples.\n Data between samples can be averaged by setting the averaging flag in the\n Data decimation register.\n @param enabled When true, the averaging is enabled, otherwise it is disabled.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetAveraging(enabled: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns information if averaging of data between samples is enabled or\n disabled. Data between samples can be averaged by setting the averaging flag\n in the Data decimation register.\n @param enabled Set to true when the averaging is enabled, otherwise is it set\n to false.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetAveraging(enabled: *mut bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the trigger source used at acquiring signal. When acquiring is started,\n the FPGA waits for the trigger condition on the specified source and when the\n condition is met, it starts writing the signal to the buffer.\n @param source Trigger source.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetTriggerSrc(source: rp_acq_trig_src_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the trigger source used at acquiring signal. When acquiring is started,\n the FPGA waits for the trigger condition on the specified source and when the\n condition is met, it starts writing the signal to the buffer.\n @param source Currently set trigger source.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetTriggerSrc(source: *mut rp_acq_trig_src_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the trigger state. Either it is waiting for a trigger to happen, or\n it has already been triggered. By default it is in the triggered state, which\n is treated the same as disabled.\n @param state Trigger state\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetTriggerState(state: *mut rp_acq_trig_state_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the number of decimated data after trigger written into memory.\n @param decimated_data_num Number of decimated data. It must not be higher\n than the ADC buffer size.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetTriggerDelay(decimated_data_num: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns current number of decimated data after trigger written into memory.\n @param decimated_data_num Number of decimated data.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetTriggerDelay(decimated_data_num: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the amount of decimated data in nanoseconds after trigger written into\n memory.\n @param time_ns Time in nanoseconds. Number of ADC samples within the\n specified time must not be higher than the ADC buffer size.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetTriggerDelayNs(time_ns: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the current amount of decimated data in nanoseconds after trigger\n written into memory.\n @param time_ns Time in nanoseconds.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetTriggerDelayNs(time_ns: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of valid data ponts before trigger.\n @param time_ns number of data points.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetPreTriggerCounter(value: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the trigger threshold value in volts. Makes the trigger when ADC value\n crosses this value.\n @param voltage Threshold value for the channel\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetTriggerLevel(
        channel: rp_channel_trigger_t,
        voltage: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets currently set trigger threshold value in volts\n @param voltage Current threshold value for the channel\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetTriggerLevel(
        channel: rp_channel_trigger_t,
        voltage: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the trigger threshold hysteresis value in volts.\n Value must be outside to enable the trigger again.\n @param voltage Threshold hysteresis value for the channel\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetTriggerHyst(voltage: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets currently set trigger threshold hysteresis value in volts\n @param voltage Current threshold hysteresis value for the channel\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetTriggerHyst(voltage: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the acquire gain state. The gain should be set to the same value as it\n is set on the Red Pitaya hardware by the LV/HV gain jumpers. LV = 1V; HV =\n 20V.\n @param channel Channel A or B\n @param state High or Low state\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqSetGain(channel: rp_channel_t, state: rp_pinState_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the currently set acquire gain state in the library. It may not be\n set to the same value as it is set on the Red Pitaya hardware by the LV/HV\n gain jumpers. LV = 1V; HV = 20V.\n @param channel Channel A or B\n @param state Currently set High or Low state in the library.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetGain(channel: rp_channel_t, state: *mut rp_pinState_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the currently set acquire gain in the library. It may not be set to\n the same value as it is set on the Red Pitaya hardware by the LV/HV gain\n jumpers. Returns value in Volts.\n @param channel Channel A or B\n @param voltage Currently set gain in the library. 1.0 or 20.0 Volts\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetGainV(channel: rp_channel_t, voltage: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns current position of ADC write pointer.\n @param pos Write pointer position\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetWritePointer(pos: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns position of ADC write pointer at time when trigger arrived.\n @param pos Write pointer position\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetWritePointerAtTrig(pos: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Starts the acquire. Signals coming from the input channels are acquired and\n written into memory.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqStart() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stops the acquire.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqStop() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resets the acquire writing state machine and set by default all parameters.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqReset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resets the acquire writing state machine.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqResetFpga() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Normalizes the ADC buffer position. Returns the modulo operation of ADC\n buffer size...\n @param pos position to be normalized\n @return Normalized position (pos % ADC_BUFFER_SIZE)"]
    pub fn rp_AcqGetNormalizedDataPos(pos: u32) -> u32;
}
extern "C" {
    #[doc = " Returns the ADC buffer in raw units from start to end position.\n\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param start_pos Starting position of the ADC buffer to retrieve.\n @param end_pos Ending position of the ADC buffer to retrieve.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @param buffer_size Length of input buffer. Returns length of filled buffer.\n In case of too small buffer, required size is returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDataPosRaw(
        channel: rp_channel_t,
        start_pos: u32,
        end_pos: u32,
        buffer: *mut i16,
        buffer_size: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ADC buffer in Volt units from start to end position.\n\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param start_pos Starting position of the ADC buffer to retrieve.\n @param end_pos Ending position of the ADC buffer to retrieve.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @param buffer_size Length of input buffer. Returns length of filled buffer.\n In case of too small buffer, required size is returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDataPosV(
        channel: rp_channel_t,
        start_pos: u32,
        end_pos: u32,
        buffer: *mut f32,
        buffer_size: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ADC buffer in raw units from specified position and desired size.\n Output buffer must be at least 'size' long.\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param pos Starting position of the ADC buffer to retrieve.\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDataRaw(
        channel: rp_channel_t,
        pos: u32,
        size: *mut u32,
        buffer: *mut i16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ADC buffer in raw units from specified position and desired size.\n Output buffer must be at least 'size' long.\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param pos Starting position of the ADC buffer to retrieve.\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDataRawV2(
        pos: u32,
        size: *mut u32,
        buffer: *mut u16,
        buffer2: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ADC buffer in raw units from the oldest sample to the newest one.\n Output buffer must be at least 'size' long.\n CAUTION: Use this method only when write pointer has stopped (Trigger\n happened and writing stopped).\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetOldestDataRaw(
        channel: rp_channel_t,
        size: *mut u32,
        buffer: *mut i16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the latest ADC buffer samples in raw units.\n Output buffer must be at least 'size' long.\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetLatestDataRaw(
        channel: rp_channel_t,
        size: *mut u32,
        buffer: *mut i16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ADC buffer in Volt units from specified position and desired\n size. Output buffer must be at least 'size' long.\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param pos Starting position of the ADC buffer to retrieve\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDataV(
        channel: rp_channel_t,
        pos: u32,
        size: *mut u32,
        buffer: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ADC buffer in Volt units from specified position and desired\n size. Output buffer must be at least 'size' long.\n @param pos Starting position of the ADC buffer to retrieve\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer1 The output buffer gets filled with the selected part of the\n ADC buffer for channel 1.\n @param buffer2 The output buffer gets filled with the selected part of the\n ADC buffer for channel 2.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDataV2(
        pos: u32,
        size: *mut u32,
        buffer1: *mut f32,
        buffer2: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ADC buffer in Volt units from specified position and desired\n size. Output buffer must be at least 'size' long.\n @param pos Starting position of the ADC buffer to retrieve\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer1 The output buffer gets filled with the selected part of the\n ADC buffer for channel 1.\n @param buffer2 The output buffer gets filled with the selected part of the\n ADC buffer for channel 2.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetDataV2D(
        pos: u32,
        size: *mut u32,
        buffer1: *mut f64,
        buffer2: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the ADC buffer in Volt units from the oldest sample to the newest\n one. Output buffer must be at least 'size' long. CAUTION: Use this method\n only when write pointer has stopped (Trigger happened and writing stopped).\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetOldestDataV(
        channel: rp_channel_t,
        size: *mut u32,
        buffer: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the latest ADC buffer samples in Volt units.\n Output buffer must be at least 'size' long.\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param size Length of the ADC buffer to retrieve. Returns length of filled\n buffer. In case of too small buffer, required size is returned.\n @param buffer The output buffer gets filled with the selected part of the ADC\n buffer.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetLatestDataV(
        channel: rp_channel_t,
        size: *mut u32,
        buffer: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_AcqGetBufSize(size: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the current calibration values from temporary memory to the FPGA filter\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqUpdateAcqFilter(channel: rp_channel_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the current calibration values from temporary memory to the FPGA filter\n @param channel Channel A or B for which we want to retrieve the ADC buffer.\n @param coef_aa Return AA coefficient.\n @param coef_bb Return BB coefficient.\n @param coef_kk Return KK coefficient.\n @param coef_pp Return PP coefficient.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_AcqGetFilterCalibValue(
        channel: rp_channel_t,
        coef_aa: *mut u32,
        coef_bb: *mut u32,
        coef_kk: *mut u32,
        coef_pp: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets generate to default values."]
    pub fn rp_GenReset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables output\n @param channel Channel A or B which we want to enable\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenOutEnable(channel: rp_channel_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Runs/Stop two channels synchronously\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenOutEnableSync(enable: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disables output\n @param channel Channel A or B which we want to disable\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenOutDisable(channel: rp_channel_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets value true if channel is enabled otherwise return false.\n @param channel Channel A or B.\n @param value Pointer where value will be returned\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenOutIsEnabled(channel: rp_channel_t, value: *mut bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets channel signal peak to peak amplitude.\n @param channel Channel A or B for witch we want to set amplitude\n @param amplitude Amplitude of the generated signal. From 0 to max value. Max\n amplitude is 1\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenAmp(channel: rp_channel_t, amplitude: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets channel signal peak to peak amplitude.\n @param channel Channel A or B for witch we want to get amplitude.\n @param amplitude Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetAmp(channel: rp_channel_t, amplitude: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets DC offset of the signal. signal = signal + DC_offset.\n @param channel Channel A or B for witch we want to set DC offset.\n @param offset DC offset of the generated signal. Max offset is 2.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenOffset(channel: rp_channel_t, offset: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets DC offset of the signal.\n @param channel Channel A or B for witch we want to get amplitude.\n @param offset Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetOffset(channel: rp_channel_t, offset: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets channel signal frequency.\n @param channel Channel A or B for witch we want to set frequency.\n @param frequency Frequency of the generated signal in Hz.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenFreq(channel: rp_channel_t, frequency: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets channel signal frequency in fpga without reset generator and rebuild\n signal.\n @param channel Channel A or B for witch we want to set frequency.\n @param frequency Frequency of the generated signal in Hz.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenFreqDirect(channel: rp_channel_t, frequency: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets channel signal frequency.\n @param channel Channel A or B for witch we want to get frequency.\n @param frequency Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetFreq(channel: rp_channel_t, frequency: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets channel sweep signal start frequency.\n @param channel Channel A or B for witch we want to set frequency.\n @param frequency Frequency of the generated signal in Hz.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenSweepStartFreq(channel: rp_channel_t, frequency: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets channel sweep signal start frequency.\n @param channel Channel A or B for witch we want to get frequency.\n @param frequency Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetSweepStartFreq(
        channel: rp_channel_t,
        frequency: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets channel sweep signal end frequency.\n @param channel Channel A or B for witch we want to set frequency.\n @param frequency Frequency of the generated signal in Hz.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenSweepEndFreq(channel: rp_channel_t, frequency: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets channel sweep signal end frequency.\n @param channel Channel A or B for witch we want to get frequency.\n @param frequency Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetSweepEndFreq(
        channel: rp_channel_t,
        frequency: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets channel signal phase. This shifts the signal in time.\n @param channel Channel A or B for witch we want to set phase.\n @param phase Phase in degrees of the generated signal. From 0 deg to 180 deg.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenPhase(channel: rp_channel_t, phase: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets channel signal phase.\n @param channel Channel A or B for witch we want to get phase.\n @param phase Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetPhase(channel: rp_channel_t, phase: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets channel signal waveform. This determines how the signal looks.\n @param channel Channel A or B for witch we want to set waveform type.\n @param form Wave form of the generated signal [SINE, SQUARE, TRIANGLE,\n SAWTOOTH, PWM, DC, ARBITRARY, SWEEP].\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenWaveform(channel: rp_channel_t, type_: rp_waveform_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets channel signal waveform.\n @param channel Channel A or B for witch we want to get waveform.\n @param type Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetWaveform(
        channel: rp_channel_t,
        type_: *mut rp_waveform_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the generation mode for the sweep signal.\n @param channel Channel A or B for witch we want to set waveform type.\n @param mode Mode of the generated signal [RP_GEN_SWEEP_MODE_LINEAR,\n RP_GEN_SWEEP_MODE_LOG].\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenSweepMode(
        channel: rp_channel_t,
        mode: rp_gen_sweep_mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the generation mode for the sweep signal.\n @param channel Channel A or B for witch we want to get waveform.\n @param mode Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetSweepMode(
        channel: rp_channel_t,
        mode: *mut rp_gen_sweep_mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the direction of frequency change for sweep.\n @param channel Channel A or B for witch we want to set waveform type.\n @param mode Wave form of the generated signal [RP_GEN_SWEEP_DIR_NORMAL,\n RP_GEN_SWEEP_DIR_UP_DOWN].\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenSweepDir(channel: rp_channel_t, mode: rp_gen_sweep_dir_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the direction of frequency change for sweep.\n @param channel Channel A or B for witch we want to get waveform.\n @param mode Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetSweepDir(
        channel: rp_channel_t,
        mode: *mut rp_gen_sweep_dir_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets user defined waveform.\n @param channel Channel A or B for witch we want to set waveform.\n @param waveform Use defined wave form, where min is -1V an max is 1V.\n @param length Length of waveform.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenArbWaveform(
        channel: rp_channel_t,
        waveform: *mut f32,
        length: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets user defined waveform.\n @param channel Channel A or B for witch we want to get waveform.\n @param waveform Pointer where waveform will be returned.\n @param length Pointer where waveform length will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetArbWaveform(
        channel: rp_channel_t,
        waveform: *mut f32,
        length: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets duty cycle of PWM signal.\n @param channel Channel A or B for witch we want to set duty cycle.\n @param ratio Ratio betwen the time when signal in HIGH vs the time when\n signal is LOW.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenDutyCycle(channel: rp_channel_t, ratio: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets duty cycle of PWM signal.\n @param channel Channel A or B for witch we want to get duty cycle.\n @param ratio Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetDutyCycle(channel: rp_channel_t, ratio: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets generation mode.\n @param channel Channel A or B for witch we want to set generation mode.\n @param mode Type of signal generation (CONTINUOUS, BURST, STREAM).\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenMode(channel: rp_channel_t, mode: rp_gen_mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets generation mode.\n @param channel Channel A or B for witch we want to get generation mode.\n @param mode Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetMode(channel: rp_channel_t, mode: *mut rp_gen_mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets number of generated waveforms in a burst.\n @param channel Channel A or B for witch we want to set number of generated\n waveforms in a burst.\n @param num Number of generated waveforms. If -1 a continuous signal will be\n generated.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenBurstCount(
        channel: rp_channel_t,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets number of generated waveforms in a burst.\n @param channel Channel A or B for witch we want to get number of generated\n waveforms in a burst.\n @param num Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetBurstCount(
        channel: rp_channel_t,
        num: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the value to be set at the end of the generated signal in burst mode.\n @param channel Channel A or B for witch we want to set number of generated\n waveforms in a burst.\n @param amplitude Amplitude level at the end of the signal (Volt).\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenBurstLastValue(channel: rp_channel_t, amlitude: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the value to be set at the end of the generated signal in burst mode.\n @param channel Channel A or B for witch we want to get number of generated\n waveforms in a burst.\n @param amplitude Amplitude where value will be returned (Volt).\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetBurstLastValue(
        channel: rp_channel_t,
        amlitude: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets number of burst repetitions. This determines how many bursts will be\n generated.\n @param channel Channel A or B for witch we want to set number of burst\n repetitions.\n @param repetitions Number of generated bursts. If 0x10000, infinite bursts\n will be generated.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenBurstRepetitions(
        channel: rp_channel_t,
        repetitions: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets number of burst repetitions.\n @param channel Channel A or B for witch we want to get number of burst\n repetitions.\n @param repetitions Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetBurstRepetitions(
        channel: rp_channel_t,
        repetitions: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the time/period of one burst in micro seconds. Period must be equal or\n greater then the time of one burst. If it is greater than the difference will\n be the delay between two consequential bursts.\n @param channel Channel A or B for witch we want to set burst period.\n @param period Time in micro seconds.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenBurstPeriod(channel: rp_channel_t, period: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the period of one burst in micro seconds.\n @param channel Channel A or B for witch we want to get burst period.\n @param period Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetBurstPeriod(channel: rp_channel_t, period: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets trigger source.\n @param channel Channel A or B for witch we want to set trigger source.\n @param src Trigger source (INTERNAL, EXTERNAL_PE, EXTERNAL_NE, GATED_BURST).\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenTriggerSource(channel: rp_channel_t, src: rp_trig_src_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets trigger source.\n @param channel Channel A or B for witch we want to get burst period.\n @param src Pointer where value will be returned.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenGetTriggerSource(
        channel: rp_channel_t,
        src: *mut rp_trig_src_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The generator is reset on both channels.\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenSynchronise() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The generator is reset on channels.\n @param channel Channel A or B\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenResetTrigger(channel: rp_channel_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Emit trigger for selected channel\n @param channel Channel A or B\n @return If the function is successful, the return value is RP_OK.\n If the function is unsuccessful, the return value is any of RP_E* values that\n indicate an error."]
    pub fn rp_GenTriggerOnly(channel: rp_channel_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_CmnCnvCntToV(
        field_len: u32,
        cnts: u32,
        adc_max_v: f32,
        calibScale: u32,
        calib_dc_off: ::std::os::raw::c_int,
        user_dc_off: f32,
    ) -> f32;
}
extern "C" {
    pub fn rp_jmd_AcqGetRawBuffer(channel: rp_channel_t) -> *const u32;
}
